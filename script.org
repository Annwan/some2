* Introduction

Here is a binary tree with seven nodes.
And here is another one. And another one.
There are five of them in total, unless we add some more nodes.

Here is a question: suppose I give you the number of nodes, say 19 or
2023, as an input. Can you write a program that generates a random tree
based on this input?

For the moment, we want that our program generates every tree with an
equal probability. That means that no tree has a preference, and all the
trees are equally likely output of our program. This is known as the
uniform distribution.

This video is about one random generating technique that
deals not only with random trees but applies to a larger
class of structures including the ones such as
    - the RNA structures,
    - XML and json instances,
    - chemical polymers
and many more.
This technique and similar ones can be used in applications
ranging from software testing to various physical simulations.

Before trying to actually treat the original brain teaser and answer the
question about random generation, let us take a moment to step onto a
philosophical field and think why would we _want_ to generate a random
binary tree in a first place?

I think this question could be split into two parts:
what is the use of a binary tree, and what is the use of random
generation?

A binary tree is a data structure that encodes a crazy amount of
real-world objects. When I say a "data structure", the most obvious
allusion is to classes from programming languages. The easiest way to
imagine a binary tree is to look at your home directory structure and
pretend that each folder can only have exactly two items inside of it,
each item being a folder or a file. Computer engineers need to know
the average behaviours of structures generated by users to optimise
performance.
Binary trees can be also used to encode discrete excursions, which in
their turn, are often used to model stock prices. 
Further on, in the science of hydrogeology, every river is considered
not just a path between two points, but rather as a binary tree that
covers all of its basins. The notion of Strahler number for
binary trees, for example, can be used to denote the stream power of a river,
and to denote the number of registers required for compilation of a
program. Don't forget that the actual trees in the woods are among
the classical examples, and that animals respiratory and circulatory
systems can be modelled by structures very close to binary trees.

To sum up, a binary tree is a very useful object, and it is reasonable
to ask about the properties of a typical large random tree.

Still, it might be a little awkward to make a _uniform_ choice from a
large set. Mathematical models can be often weird especially when it
comes to probability theory, and require additional justification when
we try to apply them to realistic scenarios. In fact, I can almost
guarantee you that if you encode a real-world structure with a binary
tree, you don't see at all the typical structure that you would expect
from a uniformly random tree. In our story, the uniform distribution
is only a starting point that gradually allows us to build up more
flexibility in how we look at the space of outcomes. This basic model is
often viewed as a toy example for gaining understanding about
what a "typical random" means. Still, even in this limited framework
there are already several applications. If you want to know the
distribution of the height of a random tree, and you don't have the
mathematical tools available, the easiest way to gain some intuition is
to perform Monte Carlo simulation, which means to sample 5000 random trees,
and calculate the height of each individual one. This gives an idea
about the properties of typical structures, that the height concentrates
around a specific number. By using such simulations, one is able to
figure out the level profile of a random tree, Strahler number and more
refined quantities.

In other words, a uniform distribution does not really model real-world
scenarios, but serves as a theoretical starting point, and can be used
to gain intuition about abstract systems.

Now, let us return to the original question: how do we generate a random
binary tree with a given number of nodes?

If you are curious and have enough computational power, you could
enumerate all such trees to have an idea how a typical large binary tree
looks like, but already with 45 nodes you would have to brute force your
way through 91.482.563.640 trees (91 billion 482 million 563 thousand
and 640) -- not a good way to go.

Still, enumerating the trees would give us some idea about their
recursive structures and we can apply this idea to random generation as
well.
When you cut the root of a tree, it falls down into two distinct trees,
the left one and the right one. Since both of the trees are smaller than
the initial tree, we could enumerate all the pairs, that is, all
possible ways of gluing two trees together into a large tree.
In this gluing, we have to make sure that the total sizes of these trees
sum up to a given number.

If you consider all possible trees with a given number of vertices, say,
7, 19 or 2023 as a probability space, you can consider at the size of the
left component as a random variable.

* example: trees with 7 vertices

If the original tree has seven nodes, then the left subtree may contain
either 1 or 3 or 5 nodes. In two cases, the left subtree has only one
node. Then, there is only one case when the left subtree has three
nodes. Finally, in two more cases, the left subtree has five nodes.

This is equivalent to saying that the discrete random variable
representing the size of the left subtree takes values 1, 3 and 5 with
respective probabilities 2/5 (two-fifths), 1/5 (one-fifth) and 2/5
(two-fifths).

Here is the first algorithm that generates a random tree with a fixed
number of vertices. We generate a number from this discrete
distribution, which gives us the size of the left subtree. By using this
number and by knowing the total size of the tree, we can calculate the
number of the remaining nodes in the right half. Both trees are then
generated recursively. Once the two smaller trees are generated, the
larger tree is glued from the two of them. This technique will guarantee
that every tree will appear with an identical probability, in other
words, that the resulting distribution on the probability space of all
binary trees is going to be uniform.

In order to make this algorithm work, we need to know the distribution
of the size of the left subtree. This can be achieved by looking at the
counting recurrence for binary trees. 

$T_n = \sum_{k=1}^{n-1} T_k \cdot T_{n-k-1}$

Let $T_n$ (T sub n) denote the number of trees with n nodes.
To calculate $T_n$ (T sub n), we need to sum over all k, where k
represents the size of the left subtree, and add the number of possible
pairs. The left subtree forms out of $T_k$ (T sub k) possibilities,
while the right one has $n-k-1$ (n minus k minus one) node
and forms out of $T_{n-k-1}$ (T sub n minus k minus one) possibilities,
so to have the total number of pairs we need to multiply these two
numbers.

So the number of combinations in which the left subtree has k nodes is
equal to the product $T_k \times T_{n-k-1}$ (T sub k times T sub n minus
k minus one). You then obtain the probability distribution by dividing
by the total sum. 


